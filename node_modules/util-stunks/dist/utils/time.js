"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultTimeOptions = void 0;
const times = __importStar(require("../info/time.json"));
exports.defaultTimeOptions = {
    compact: false,
    display: 7,
    removeMs: false,
    includeMsInSeconds: false,
};
function replace(inputString) {
    const lastIndex = inputString.lastIndexOf(',');
    if (lastIndex === -1) {
        return inputString;
    }
    const beforeLastComma = inputString.slice(0, lastIndex);
    const afterLastComma = inputString.slice(lastIndex + 1);
    return beforeLastComma + " e" + afterLastComma;
}
exports.default = (input, options = exports.defaultTimeOptions) => {
    if (isNaN(input))
        throw new TypeError('Parâmetro input deve ser do tipo numérico');
    const userOption = { ...exports.defaultTimeOptions, ...options };
    const intervalsInMilliseconds = {
        years: 1000 * 60 * 60 * 24 * 365.25,
        months: 1000 * 60 * 60 * 24 * 30.4375,
        days: 1000 * 60 * 60 * 24,
        hours: 1000 * 60 * 60,
        minutes: 1000 * 60,
        seconds: 1000,
        milliseconds: 1,
    };
    let timeIntervals = {};
    let ms = input;
    for (const interval in intervalsInMilliseconds) {
        if (ms >= intervalsInMilliseconds[interval]) {
            const val = Math.floor(ms / intervalsInMilliseconds[interval]);
            timeIntervals[interval] = val;
            ms -= val * intervalsInMilliseconds[interval];
        }
    }
    const time = {};
    for (const interval in timeIntervals) {
        const val = timeIntervals[interval];
        if (val && userOption.display) {
            if (interval === 'milliseconds') {
                if (userOption.removeMs)
                    continue;
                if (userOption.includeMsInSeconds && time.seconds) {
                    time.seconds = Number(time.seconds + '.' + String(val).padStart(3, '0').slice(0, 1));
                }
                else {
                    time.milliseconds = val;
                }
            }
            else {
                time[interval] = val;
            }
            userOption.display--;
        }
    }
    let result = '';
    let isFirst = true;
    for (const interval in times) {
        const val = times[interval];
        const value = time[interval];
        if (value !== undefined) {
            result += !isFirst && !userOption.compact ? ", " : " ";
            if (userOption.compact) {
                result += `${value}${val.compact}`;
            }
            else if (value > 1) {
                result += `${value} ${val.plural}`;
            }
            else {
                result += `${value} ${val.unique}`;
            }
            isFirst = false;
        }
    }
    result = replace(result);
    return result.trim() || "";
};
